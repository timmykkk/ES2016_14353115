#  Deadlock
 ***
1 用bash运行批处理文件的结果

![](https://raw.githubusercontent.com/timmykkk/ES2016_14353115/master/deadlock9.png)  

可以看到第九次就产生了死锁。没有继续执行下去。

2 死锁的四个必要条件：  
（1）互斥条件：一个资源每次只能被一个进程使用。  
（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  
（3）不剥夺条件：一个进程已经获得的资源，在未使用完之前，其他进程不能强行抢夺。  
（4）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。  

3 本程序死锁产生的原因：
在第一次执行Deadlock.java的线程t开始的20000个count时间后，a.methodA(b)才会被执行。  
而在第九次执行Deadlock.java的时候，如果这时刚好第一个线程的20000个count数完，a.method(b)要调用b的方法，
然后这第九次执行正好调度到了run()函数，有一个b.method(a)要又调用a的方法，但是又不能同时调用，因为有synchronized关键字，而且一个对象执行函数必然会让另一个对象也执行，所以两者都不能执行。这样就进入了循环等待状态。也就是死锁状态。
可能因为调度到run()函数的方法的时间是随机的，所以产生死锁的时间也是随机的。

